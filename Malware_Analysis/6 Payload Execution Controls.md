
# Summary
This time we are going to analyze 3 different methods to control the execution of the payload. There are several types of synchronization objects, including [semaphores](https://learn.microsoft.com/en-us/windows/win32/sync/semaphore-objects), [mutexes](https://learn.microsoft.com/en-us/windows/win32/sync/mutex-objects), and [events](https://learn.microsoft.com/en-us/windows/win32/sync/event-objects). Each type of synchronization object works in a slightly different manner but ultimately they all serve the same purpose which is to coordinate access of shared resources.


# Sample 1 (Semaphore)

We can see see at at this `main()` subroutine is very small, is only calls 1 other subroutine named `IsPayloadRunning()` which we will dive into a bit. First we can see that the main function is subtracting 0x38 (56 bytes) from rsp register, this is done in order to make space space on the stack.

Next,  another subroutine is called at: `140001244` named: `IsPayloadRunning()`
![[Pasted image 20240509161628.png]]

This subroutine  called ``CreateSemaphoreA()`` WinAPI. This Windows API, is responsible for creating / opening a semaphore object. In this case a named semaphore to prevent executions after the initial binary run. If the named semaphore is already running, `CreateSemaphoreA` will return a handle to the existing object and `GetLastError` will return `ERROR_ALREADY_EXISTS`.

![[Pasted image 20240509162954.png]]

After a new semaphore object has been created, the next stage is to run the actual payload. This is done via `CreateThread()` and assign `lpStartAddress` to our payload. Next after successful execution, the program is going to check whether a semaphore named object has been created named `0xBinary` if not, the program is going to create thread if the named semaphore already exists the program will print `[+] Payload Is Already Running\n`.

![[Pasted image 20240509163343.png]]


## Pseudo-Code C Sempahore

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  if ( !IsPayloadRunning() )
    CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)Payload, 0i64, 0, 0i64);
  if ( IsPayloadRunning() )
    printf("[+] Payload Is Already Running \n");
  else
    CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)Payload, 0i64, 0, 0i64);
  getchar();
  return 0;
}
```


# Mutex

Mutex is a specific kind of binary semaphore that is used to provide a locking mechanism. It stands for [Mutual Exclusion](https://www.geeksforgeeks.org/mutual-exclusion-in-synchronization/) Object. Mutex is mainly used to provide mutual exclusion to a specific portion of the code so that the process can execute and work with a particular section of the code at a particular time.

The binary looks very the same as functionality as semaphore, therefore we are only gong to dive into the mutex functionality inside this specimen.

We can see the screenshot below, that it's creating mutex named object, therefore it's locking this object in order to execute `CreateThread()` once.

![[Pasted image 20240509192233.png]]


```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 MutexString; // r8

  if ( !(unsigned int)IsPayloadRunning(argc, argv, envp) )
  {
    printf("[i] Running Payload [1] ... ");
    CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)Payload, 0i64, 0, 0i64);
    printf("[+] DONE \n");
  }
  if ( (unsigned int)IsPayloadRunning(v4, v3, MutexString) )
  {
    printf("[+] Payload Is Already Running \n");
  }
  else
  {
    printf("[i] Running Payload [2] ... ");
    CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)Payload, 0i64, 0, 0i64);
    printf("[+] DONE \n");
  }
  getchar();
  return 0;
}
```