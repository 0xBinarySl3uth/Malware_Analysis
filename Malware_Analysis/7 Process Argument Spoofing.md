Process Argument spoofing is a technique used to conceal the command line arguments of a newly spawned process. Process argument spoofing is done by the following steps:
1. Create process in suspended state.
2. Get remote PEB address of the suspended process.
3. Read remote PEB struct from the suspended process.
4. Read remote `PEB->ProcessParameters` structure from the suspended process.
5. Patch the string ``ProcessParameters.Commandline.Bufffer`` & overwrite with the payload to execute (this case `mstsc.exe`).


# Identifying Helper Functions
This specimen has 2 helper functions, based on their functionality I have named them: 
1. `ReadSuspendedProcess`
2. `WriteSuspendedProcess`


## ReadSuspendedProcess 

This subroutine is responsible for reading the remote created process (suspended). The subroutine does this by first allocating memory on the heap. (`14000115F`).

![[Pasted image 20240510112742.png]]

Next, the subroutine will return the value of `ReadProcessMemory`. This subroutine has some parameters which I am going to explain below.
1. `hProcess` - Represents the handle to the suspended remote process.
2. `lpBaseAddressHeapAlloc` - Points to the base address of the memory block allocated from the heap, from which `ReadProcessMemory` will read data.
3. `lpBuffer` - Serves as the buffer that will receive the data read by `ReadProcessMemory` from the allocated memory block.
4. `dwSize` - Holds 4 bytes (DWORD), specifying the number of bytes to read from the allocated heap memory.
5. `lpNumberOfBytesRead` - A pointer intended to receive the number of bytes read from the allocated heap memory by `ReadProcessMemory`.

![[Pasted image 20240510152632.png]]

t address `0x1400011BF`, the `retn` instruction is used to exit the `ReadSuspendedProcess` function and return control to the calling code.

![[Pasted image 20240510152809.png]]
### Summary of ReadSuspendedProcess

This helper function facilitates the allocation of memory to read the memory of a remote (suspended) process. If it successfully retrieves a handle to the remote process, the subroutine returns control to the calling code, specifically to the function `CreateArgSpoofedProcess`.


# WriteSuspendProcess

This subroutine will patch the parameters of the PowerShell command. It will do this by accessing ``PEB->ProcessParameter`` member and modify its member value.

![[Pasted image 20240511111142.png]]

## Summary Of WriteSuspendedProcess

The subroutine "``WriteSuspendedProcess``" facilitates the injection of data into a suspended remote process using the Windows API function `WriteProcessMemory`. It requires six parameters:

1. `hProcess`: Represents the handle to the suspended remote process.
2. `lpBaseAddress`: Points to the base address within the remote process where the data will be written.
3. `lpBuffer`: Contains the data to be written into the remote process.
4. `nSize`: Specifies the size, in bytes, of the data to be written.
5. `lpNumberOfBytesWritten`: A pointer that receives the number of bytes successfully written into the remote process.
6. `lpOriginalProtection`: **Optional** parameter pointing to a variable that will receive the previous protection value of the memory region, which can be used for restoration purposes.


# CreateArgSpoofedProcess

The first section of the subroutine initializes various structures and variables. It clears memory regions and sets up necessary pointers. Additionally, it retrieves the address of the `NtQueryInformationProcess` function from the `NTDLL` module. This function is crucial as it allows the subroutine to access the `PROCESS_BASIC_INFORMATION` structure of the remote suspended process. This structure contains  the address of the Process Environment Block (PEB), which is essential for modifying the command line argument of the remote process.

![[Pasted image 20240511160029.png]]

At `loc_140001329`, the subroutine proceeds to handle the following tasks:

1. Copies the fake arguments into the buffer using the `lstrcpyW` `(0x140001339)` Windows API function.
2. Initializes various parameters required for calling the `CreateProcessW`  function, such as the startup information, current directory, environment, creation flags, and handle inheritance.
3. Calls the `CreateProcessW` `(0x14000138B)`function with the appropriate parameters, including the fake arguments.

The subroutine then checks the return value of `CreateProcessW`

![[Pasted image 20240511161202.png]]

At `loc_14000139C`, the subroutine continues its execution by performing the following actions:

1. Retrieves the `PROCESS_BASIC_INFORMATION` structure of the remote process, which contains essential information such as the Process Environment Block (PEB) address.
2. Prepares to patch the fake arguments with malicious ones by setting up a helper function.
3. Stores the address of the `PROCESS_BASIC_INFORMATION` structure in a designated location.
4. Sets up parameters for calling the `NtQueryInformationProcess` function, including the handle to the remote process and pointers to required structures.
5. Calls the `NtQueryInformationProcess` function to retrieve information about the remote process.
6. Stores the return status of the function call.
7. Checks if the function call was successful, indicated by a status value of zero, and jumps to a specified location if successful.

![[Pasted image 20240511161928.png]]

At `loc_14000148B`, the subroutine proceeds with the following actions:

1. Calls the `GetProcessHeap` function to retrieve a handle to the process heap.
2. Utilizes the `HeapFree` function to release memory allocated for the read buffer (`ppReadBuffer`) associated with the remote process.
3. Again calls `GetProcessHeap` to obtain a handle to the process heap.
4. Invokes `HeapFree` to deallocate memory allocated for the memory buffer (`lpMem`) used in the subroutine.
5. Retrieves the handle to the thread of the suspended remote process from the `ProcessInformation` structure and resumes its execution using `ResumeThread`.
6. Transfers the process and thread identifiers (PID and TID) to specified memory locations for later reference.
7. Checks if the process handle is valid by comparing it to zero and jumps to `loc_140001519` if it is.

![[Pasted image 20240511165125.png]]




