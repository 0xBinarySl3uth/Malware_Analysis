 We are going to analyse APC-Injection technique, we will do it by using Binary Ninja and IDA PRO since we want to learn both decompilers usage.

# Binary Ninja

Upon loading the sample into Binary Ninja, it shows us the main function of the program. We have opened 2 views, 1 HLIL and 1 Disassembly view. This is the view that I personally like the most, since the left view is meant for readability and the right view is to understand what is happening at a lower level. (ASM)

![[Pasted image 20240502102932.png]]
## Analyse Main Function Part 1

By analysing the main subroutine, we are able to conclude several key points.
`zq.q`, zero-extended qword (8 bytes) this means it will add the unsigned int (number) to the variable ``var_dwThreadId`` before we are going to dive into that subroutine, we first want to get a better understanding what ``AlterableFunction5(``) does and why it's being called.

![[Pasted image 20240502124312.png]]


## Analyse AlertableFuntion5

- **CreateEventW() Function Calls**: The subroutine calls `CreateEventW()` twice, each time creating an event object. This function is indeed responsible for creating event objects in Windows. The parameters passed (`lpEventAttributes`, `bManualReset`, `bInitialState`, `lpName`) specify the attributes of the event to be created.

- **Comparison with 0**: After the `CreateEventW()` calls, the return values (handles to the event objects) are stored in the `rax` and `rax_1` variables. The subsequent code then checks if both handles are not equal to 0. This check ensures that both `CreateEventW()` calls were successful in creating valid event objects. If either of them failed, the handle returned would be `NULL` (0), indicating failure.

- **RAX** : The comparison `if (rax != 0 && rax_1 != 0)` indeed checks whether the `rax` and `rax_1` registers hold valid handles to the event objects.

- **SingleObjectAndWait()** : This WinAPI is responsible for waiting on the event infinitely and make the event in an alterable state.
![[Pasted image 20240502132153.png]]

We now know, that this function is responsible for creating an event in alterable mode. Since we have gained this information, we can go back to the main subroutine and further analyze it's purpose.


## Analyse Main Function Part 2

Since we have analysed `AlterableFunction5`, we can now say that there will be a thread created in an alterable state.

![[Pasted image 20240502132736.png]]


**Thread Creation:**
- A thread is created using `CreateThread`.
- The function `AlertableFunction5` is designated as the entry point.
- If thread creation is successful, the Thread ID is printed.

**Memory Allocation and Payload Initialization:**
- Memory is allocated using `VirtualAlloc`.
- The payload is copied into the allocated memory in blocks of 128 bytes.
- Details of payload copying and memory address are printed.
**Memory Protection and Execution:**
- Memory protection is changed to allow payload execution.
- User input is prompted before payload execution.
- APC object is created to execute the payload.
- Successful execution confirmation is printed.

**Thread Synchronization and Completion:**

- The main thread waits for the APC execution to finish.
- User prompt to exit is displayed.

The code involves creating a thread, allocating memory for payload, copying payload to memory, changing memory protection for payload execution, executing payload using APC, and waiting for execution to complete.

![[Pasted image 20240502135211.png]]

# IDA

I only will show the steps without to much explanation.

## AlterableFunction5


![[Pasted image 20240502135602.png]]

## Main Function

![[Pasted image 20240502135929.png]]
