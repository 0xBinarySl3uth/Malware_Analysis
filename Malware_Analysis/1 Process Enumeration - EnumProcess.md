
## Main subroutine

The screenshot below shows the main function, we can see this is a quite basic main function that only calls 1 function `GetRemoteProcessHandle()` which we will reverse next before we continue with the rest of the `main()` subroutine.

First it's going to start with the prologue, making space onto the stack for the parameters/variables.

The main function will load the handle to the process, and handle to the PID. In order to know what will happen when those parameters are provided we have to dive into the `GetRemoteProcessHandle()` subroutine.
![[Pasted image 20240501153425.png]]

## GetRemoteProcessHandle

The function is going to make a call to EnumProcess which allows the program to gather processes that are present on the target machine.

![[Pasted image 20240501155116.png]]

Based on the return value, it will either exit the program or will continue with the next routine.

## Subroutine Flow
**When jump flag has the value: 1**
![[Pasted image 20240501155425.png]]

## Subroutine Flow
**When jump flag has the value: 0**

### Print Number Processes

![[Pasted image 20240501161551.png]]

### Seeking to Find Target Process

It irates over each process, with full access. After that the it will gather `GetModuleBaseName()`  because that is required by the next called WinAPI. 

![[Pasted image 20240501162931.png]]

It will continue to loop until there is a match if there is no match, the program will exit.
![[Pasted image 20240501175954.png]]



```c
__int64 __fastcall GetRemoteProcessHandle(const wchar_t *a1, unsigned int *p_dwPid, void **p_hProcess)
{
  unsigned int b_TRUE; // ebp
  DWORD LastError; // eax
  unsigned int v8; // r14d
  unsigned int v9; // esi
  DWORD *v10; // rbx
  HANDLE v11; // rax
  void *hProcess; // rdi
  DWORD v13; // eax
  DWORD v14; // eax
  __int64 v15; // rax
  HMODULE hModule; // [rsp+20h] [rbp-2268h] BYREF
  unsigned int cbNeeded; // [rsp+28h] [rbp-2260h] BYREF
  unsigned int v18; // [rsp+2Ch] [rbp-225Ch] BYREF
  int idProcess[2048]; // [rsp+30h] [rbp-2258h] BYREF
  __int16 var_szProc[264]; // [rsp+2030h] [rbp-258h] BYREF

  b_TRUE = 0;
  cbNeeded = 0;
  v18 = 0;
  hModule = 0i64;
  if ( !K32EnumProcesses((DWORD *)idProcess, 0x2000u, &cbNeeded) )
  {
    LastError = GetLastError();
    printf("[!] EnumProcesses Failed With Error : %d \n", LastError);
    return 0i64;
  }
  v8 = cbNeeded >> 2;
  printf("[i] Number Of Processes Detected : %d \n", cbNeeded >> 2);
  v9 = 0;
  if ( v8 )
  {
    v10 = (DWORD *)idProcess;
    do
    {
      if ( *v10 )
      {
        v11 = OpenProcess(0x1FFFFFu, 0, *v10);
        hProcess = v11;
        if ( v11 )
        {
          if ( K32EnumProcessModules(v11, &hModule, 8u, &v18) )
          {
            if ( K32GetModuleBaseNameW(hProcess, hModule, (LPWSTR)var_szProc, 0x104u) )
            {
              v15 = 0i64;
              while ( aSvchostExe[v15] == var_szProc[v15] && aSvchostExe[v15 + 1] == var_szProc[v15 + 1] )
              {
                v15 += 2i64;
                if ( v15 == 12 )
                {
                  *p_dwPid = idProcess[v9];
                  *p_hProcess = hProcess;
                  goto LABEL_20;
                }
              }
            }
            else
            {
              v14 = GetLastError();
              printf("[!] GetModuleBaseName Failed [ At Pid: %d ] With Error : %d \n", *v10, v14);
            }
          }
          else
          {
            v13 = GetLastError();
            printf("[!] EnumProcessModules Failed [ At Pid: %d ] With Error : %d \n", *v10, v13);
          }
          CloseHandle(hProcess);
        }
      }
      ++v9;
      ++v10;
    }
    while ( v9 < v8 );
  }
LABEL_20:
  if ( !*p_dwPid )
    return 0i64;
  LOBYTE(b_TRUE) = *p_hProcess != 0i64;
  return b_TRUE;
}
```